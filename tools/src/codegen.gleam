// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.

import gleam/dict
import gleam/dynamic
import gleam/http/request
import gleam/http/response
import gleam/httpc
import gleam/int
import gleam/json
import gleam/list
import gleam/pair
import gleam/result
import gleam/string
import gleam/uri
import simplifile

const entities_list_url = "https://html.spec.whatwg.org/entities.json"

const output_file = "../src/commonmark/internal/parser/entity.gleam"

const entities_header = "////
//// WARNING: This file is autogenerated. Modifications to this file will not persist.
////
//// You can run `gleam run -m codegen` to update it if you think there are entities missing.
////
//// Data sourced from https://html.spec.whatwg.org/entities.json
////

// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.

import gleam/list
import gleam/string
"

const entities_footer = ""

type EntityEntry {
  EntityEntry(characters: String, codepoints: List(Int))
}

fn fetch_entities() -> List(#(String, List(Int))) {
  let assert Ok(response.Response(_, _, body)) =
    entities_list_url
    |> uri.parse
    |> result.try(request.from_uri)
    |> result.map_error(dynamic.from)
    |> result.try(httpc.send)

  let entity_decoder =
    dynamic.dict(
      of: dynamic.string,
      to: dynamic.decode2(
        EntityEntry,
        dynamic.field("characters", dynamic.string),
        dynamic.field("codepoints", dynamic.list(dynamic.int)),
      ),
    )

  let assert Ok(results) = json.decode(from: body, using: entity_decoder)

  results
  |> dict.map_values(fn(_, x) { x.codepoints })
  |> dict.to_list
}

fn is_relevant(entity: #(String, List(Int))) -> List(#(String, List(Int))) {
  case string.ends_with(entity.0, ";"), entity {
    True, #("&" <> rest, mapping) -> [#(rest, mapping)]
    _, _ -> []
  }
}

fn format_lines(line) {
  case line {
    #(graphemes, mapping) ->
      "    \""
      <> graphemes
      <> "\" <> _ -> Ok(#(list.drop(input, "
      <> { string.length(graphemes) |> int.to_string }
      <> "), \""
      <> graphemes
      <> "\", \""
      <> {
        mapping
        |> list.map(fn(cp) { "\\u{" <> int.to_base16(cp) <> "}" })
        |> string.join("")
      }
      <> "\"))"
  }
}

pub fn safe_prefix(prefix: String) {
  let lcase = string.lowercase(prefix)
  case prefix == lcase {
    True -> prefix
    False -> "upper_" <> lcase
  }
}

pub fn main() {
  let entities =
    fetch_entities()
    |> list.flat_map(is_relevant)
    |> list.group(fn(x) {
      let assert Ok(c) = string.first(x.0)
      c
    })
    |> dict.to_list
  let functions =
    entities
    |> list.sort(fn(l, r) { string.compare(l.0, r.0) })
    |> list.map(fn(pair) {
      let #(prefix, es) = pair
      let case_statements =
        es
        |> list.sort(fn(l, r) { string.compare(l.0, r.0) })
        |> list.map(format_lines)
        |> string.join("\n")

      #(
        prefix,
        "\nfn match_"
          <> safe_prefix(prefix)
          <> "(entity: String, input: List(String)) {\n  case entity {\n"
          <> case_statements
          <> "\n    _ -> Error(Nil)\n  }\n}\n",
      )
    })

  let entry = "
pub fn match_html_entity(input: List(String)) -> Result(#(List(String), String, String), Nil) {
  let entity = input |> list.take(40) |> string.join(\"\")
  case list.first(input) {
" <> {
      functions
      |> list.map(pair.first)
      |> list.map(fn(s) {
        "    Ok(\"" <> s <> "\") -> match_" <> safe_prefix(s)
      })
      |> string.join("\n")
    } <> "
    _ -> fn(_, _) { Error(Nil) }
  }(entity, input)
}
"

  let contents =
    entities_header
    <> entry
    <> { functions |> list.map(pair.second) |> string.join("") }
    <> entities_footer

  let assert Ok(_) = simplifile.write(to: output_file, contents: contents)

  Nil
}
